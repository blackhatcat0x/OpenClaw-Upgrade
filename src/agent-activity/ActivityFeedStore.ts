/**
 * ActivityFeedStore: persists short one-liner agent status updates.
 *
 * Enforces a rate limit (1 update per MIN_INTERVAL_MS per agent).
 * Stores the last MAX_STORED entries; older ones are pruned automatically.
 *
 * Used by AgentRunner to write status updates generated by the cheap
 * "status_ping" model route (not the main reasoning model).
 */

import { randomUUID } from "node:crypto";
import { mkdir } from "node:fs/promises";
import { join } from "node:path";
import type { DatabaseSync } from "node:sqlite";
import { requireNodeSqlite } from "../memory/sqlite.js";

const MIN_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes between updates per agent
const MAX_STORED = 200; // Keep last 200 entries total

export type ActivityEntry = {
  id: string;
  agentId: string;
  taskId?: string;
  /** One-liner (max 120 chars) */
  message: string;
  createdAt: string;
};

export type ActivityEntryInput = Omit<ActivityEntry, "id" | "createdAt">;

export class ActivityFeedStore {
  private db: DatabaseSync;
  /** Last write time per agent (in-memory rate limit) */
  private lastWriteAt = new Map<string, number>();

  constructor(dbPath: string) {
    const { DatabaseSync } = requireNodeSqlite();
    this.db = new DatabaseSync(dbPath);
    this.initialize();
  }

  private initialize(): void {
    this.db.exec("PRAGMA journal_mode = WAL");
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS agent_activity (
        id TEXT PRIMARY KEY,
        agent_id TEXT NOT NULL,
        task_id TEXT,
        message TEXT NOT NULL,
        created_at TEXT NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_activity_agent_time
        ON agent_activity (agent_id, created_at DESC);
    `);
  }

  /**
   * Append a status update. Returns false if rate-limited.
   * @param force - If true, bypass the rate limit (e.g. on task completion)
   */
  async append(input: ActivityEntryInput, force = false): Promise<ActivityEntry | false> {
    const now = Date.now();
    const lastWrite = this.lastWriteAt.get(input.agentId) ?? 0;

    if (!force && now - lastWrite < MIN_INTERVAL_MS) {
      return false;
    }

    const entry: ActivityEntry = {
      id: randomUUID(),
      agentId: input.agentId,
      taskId: input.taskId,
      message: (input.message ?? "").slice(0, 120),
      createdAt: new Date(now).toISOString(),
    };

    this.db
      .prepare(
        `INSERT INTO agent_activity (id, agent_id, task_id, message, created_at)
         VALUES (?, ?, ?, ?, ?)`,
      )
      .run(
        entry.id,
        entry.agentId,
        entry.taskId ?? null,
        entry.message,
        entry.createdAt,
      );

    this.lastWriteAt.set(input.agentId, now);

    // Prune old entries (keep most recent MAX_STORED)
    this.pruneIfNeeded();

    return entry;
  }

  /** List recent activity entries for an agent */
  list(agentId: string, limit = 20): ActivityEntry[] {
    const rows = this.db
      .prepare(
        `SELECT * FROM agent_activity WHERE agent_id = ? ORDER BY created_at DESC LIMIT ?`,
      )
      .all(agentId, limit) as Record<string, unknown>[];

    return rows.map((r) => this.rowToEntry(r));
  }

  /** List recent activity across all agents */
  listAll(limit = 50): ActivityEntry[] {
    const rows = this.db
      .prepare(`SELECT * FROM agent_activity ORDER BY created_at DESC LIMIT ?`)
      .all(limit) as Record<string, unknown>[];

    return rows.map((r) => this.rowToEntry(r));
  }

  private pruneIfNeeded(): void {
    const count = (
      this.db.prepare(`SELECT COUNT(*) as cnt FROM agent_activity`).get() as { cnt: number }
    ).cnt;

    if (count > MAX_STORED) {
      this.db.exec(`
        DELETE FROM agent_activity WHERE id IN (
          SELECT id FROM agent_activity ORDER BY created_at ASC LIMIT ${count - MAX_STORED}
        )
      `);
    }
  }

  private rowToEntry(row: Record<string, unknown>): ActivityEntry {
    return {
      id: row.id as string,
      agentId: row.agent_id as string,
      taskId: (row.task_id as string) || undefined,
      message: row.message as string,
      createdAt: row.created_at as string,
    };
  }

  close(): void {
    this.db.close();
  }
}

/** Open or create an activity feed store */
export async function openActivityFeedStore(baseDir: string): Promise<ActivityFeedStore> {
  await mkdir(baseDir, { recursive: true });
  const dbPath = join(baseDir, "agent-activity.db");
  return new ActivityFeedStore(dbPath);
}
